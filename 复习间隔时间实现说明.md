# 复习间隔时间实现说明

## ✅ 已完成的实现

### 1. 创建 `review_schedule` 表

```sql
CREATE TABLE review_schedule (
    id TEXT PRIMARY KEY,
    card_id TEXT NOT NULL UNIQUE,
    next_review_at TEXT NOT NULL,  -- ISO 8601格式
    review_count INTEGER DEFAULT 0,
    FOREIGN KEY (card_id) REFERENCES flash_cards(id) ON DELETE CASCADE
);
```

**索引**：
- `idx_review_schedule_next_review`：加速按时间查询
- `idx_review_schedule_card_id`：加速按卡片ID查询

### 2. 复习时间间隔规则

根据文档设计，实现了以下复习间隔：

| 状态 | 复习间隔 | next_review_at 计算 |
|------|---------|---------------------|
| `needsReview`（需要复习） | **1天** | 当前时间 + 24小时 |
| `needsImprove`（需改进） | **3天** | 当前时间 + 72小时 |
| `mastered`（已掌握） | **7天** | 当前时间 + 7天 |
| `notStarted`（未开始） | **4小时** | 当前时间 + 4小时 |

### 3. 自动计算复习时间

#### 创建词条时
- 在 `create_flash_cards()` 方法中，为新词条自动创建复习计划
- `notStarted` 状态：4小时后复习

#### 更新状态时
- 在 `update_flash_card_status()` 方法中，根据新状态计算下次复习时间
- 如果复习计划已存在，更新 `next_review_at` 并增加 `review_count`
- 如果复习计划不存在，创建新的复习计划

### 4. 基于时间的查询过滤

#### `get_review_flash_cards()`
- **默认行为**（`include_all=False`）：
  - 只返回状态为 `needsReview` 或 `needsImprove` 的词条
  - **且** `next_review_at <= 当前时间`（已到复习时间）
  - 按 `next_review_at` 升序排序（优先显示最早需要复习的）

- **全部模式**（`include_all=True`）：
  - 返回所有状态的词条（不基于时间过滤）

#### `get_today_review_statistics()`
- 统计时基于时间判断
- 只统计 `next_review_at <= 当前时间` 的词条

---

## 🔄 工作流程

### 1. 创建词条
```
用户创建笔记 → 生成闪词卡片
    ↓
创建 flash_cards 记录（status='notStarted'）
    ↓
创建 review_schedule 记录（next_review_at = 当前时间 + 4小时）
```

### 2. 更新状态
```
用户学习词条 → 更新状态
    ↓
更新 flash_cards.status 和 last_reviewed_at
    ↓
根据新状态计算 next_review_at：
  - needsReview → +1天
  - needsImprove → +3天
  - mastered → +7天
  - 其他 → +4小时
    ↓
更新或创建 review_schedule 记录
```

### 3. 查询需要复习的词条
```
用户进入学习中心
    ↓
调用 get_review_flash_cards(include_all=False)
    ↓
SQL查询：
  - 状态 IN ('needsReview', 'needsImprove')
  - AND next_review_at <= 当前时间
    ↓
返回已到复习时间的词条
```

---

## 📊 数据示例

### review_schedule 表示例

| id | card_id | next_review_at | review_count |
|----|---------|----------------|--------------|
| uuid1 | card1 | 2024-01-02T10:00:00 | 0 |
| uuid2 | card2 | 2024-01-04T10:00:00 | 1 |
| uuid3 | card3 | 2024-01-08T10:00:00 | 2 |

### 查询示例

**当前时间**：`2024-01-02T09:00:00`

**需要复习的词条**：
- `card1`（next_review_at = 2024-01-02T10:00:00）→ ❌ 还没到时间
- `card2`（next_review_at = 2024-01-04T10:00:00）→ ❌ 还没到时间
- `card3`（next_review_at = 2024-01-08T10:00:00）→ ❌ 还没到时间

**当前时间**：`2024-01-02T11:00:00`

**需要复习的词条**：
- `card1`（next_review_at = 2024-01-02T10:00:00）→ ✅ 已到时间，需要复习

---

## 🧪 测试建议

### 1. 测试创建词条
```python
# 创建新词条
cards = db.create_flash_cards(note_id, ["词条1", "词条2"])

# 检查复习计划
# 应该为每个词条创建 next_review_at = 当前时间 + 4小时
```

### 2. 测试更新状态
```python
# 更新状态为 needsReview
db.update_flash_card_status(note_id, "词条1", "needsReview")

# 检查复习计划
# next_review_at 应该更新为 当前时间 + 1天
```

### 3. 测试时间过滤
```python
# 查询需要复习的词条
cards = db.get_review_flash_cards(include_all=False)

# 应该只返回 next_review_at <= 当前时间 的词条
```

---

## 📝 迁移脚本

为现有词条初始化复习计划，运行：

```bash
cd backend
python3 migrate_review_schedule.py
```

脚本会：
1. 查找所有没有复习计划的词条
2. 根据当前状态计算 `next_review_at`
3. 创建复习计划记录

---

## 🎯 效果

### 之前
- ❌ 没有基于时间的复习间隔
- ❌ "今日复习"显示所有 `needsReview` 和 `needsImprove` 状态的词条
- ❌ 不会根据时间判断是否需要复习

### 现在
- ✅ 实现了基于时间的复习间隔
- ✅ "今日复习"只显示已到复习时间的词条
- ✅ 根据状态自动计算下次复习时间
- ✅ 按复习时间优先级排序（最早需要复习的优先）

---

## 🔍 关键代码位置

### 后端
- **数据库初始化**：`backend/database.py` → `_init_db()`
- **创建词条**：`backend/database.py` → `create_flash_cards()`
- **更新状态**：`backend/database.py` → `update_flash_card_status()`
- **查询复习卡片**：`backend/database.py` → `get_review_flash_cards()`
- **统计复习数据**：`backend/database.py` → `get_today_review_statistics()`

### 迁移脚本
- **初始化复习计划**：`backend/migrate_review_schedule.py`
