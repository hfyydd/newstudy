# 数据库修复说明

## 🔍 问题发现

用户发现：**测试笔记都删除了，但词条还在数据库中**，说明删除笔记时没有正确级联删除关联的词条。

## 🐛 根本原因

1. **SQLite 外键约束默认关闭**
   - SQLite 为了兼容性，默认关闭外键约束
   - 即使表结构中有 `ON DELETE CASCADE`，如果外键约束未启用，级联删除不会生效

2. **孤立数据**
   - 查询发现：有 **103 个孤立的词条**（对应的笔记已不存在）
   - 这些词条占用数据库空间，影响数据一致性

## ✅ 修复方案

### 1. 启用外键约束

在 `Database._get_connection()` 方法中添加：

```python
def _get_connection(self) -> sqlite3.Connection:
    """获取数据库连接"""
    conn = sqlite3.connect(self.db_path)
    conn.row_factory = sqlite3.Row
    # 启用外键约束（SQLite 默认关闭，需要显式启用）
    conn.execute("PRAGMA foreign_keys = ON")
    return conn
```

### 2. 增强删除笔记方法

修改 `Database.delete_note()` 方法，手动删除关联的词条（双重保险）：

```python
def delete_note(self, note_id: str) -> bool:
    """删除笔记（级联删除关联的闪词卡片）"""
    # ...
    # 先手动删除关联的闪词卡片
    cursor.execute("DELETE FROM flash_cards WHERE note_id = ?", (note_id,))
    deleted_cards_count = cursor.rowcount
    
    # 再删除笔记
    cursor.execute("DELETE FROM notes WHERE id = ?", (note_id,))
    deleted_notes_count = cursor.rowcount
    
    # 记录日志
    if deleted_notes_count > 0:
        print(f"[Database] 删除笔记 {note_id}，同时删除了 {deleted_cards_count} 个关联的闪词卡片")
```

### 3. 清理孤立数据

执行清理脚本，删除所有孤立的词条：

```python
# 删除所有 note_id 不在 notes 表中的词条
DELETE FROM flash_cards
WHERE note_id NOT IN (SELECT id FROM notes)
```

## 📊 修复结果

- ✅ **已清理 103 个孤立的词条**
- ✅ **外键约束已启用**（通过 Database 类获取连接时）
- ✅ **删除笔记时会正确删除关联的词条**

## 🔒 数据完整性保障

现在删除笔记时：
1. **外键约束**：如果启用，会自动级联删除（第一层保障）
2. **手动删除**：显式删除关联词条（第二层保障）
3. **双重保险**：确保即使外键约束未生效，也能正确删除

## 📝 注意事项

1. **外键约束只在通过 Database 类获取连接时启用**
   - 如果直接使用 `sqlite3.connect()`，外键约束仍然是关闭的
   - 所有数据库操作都应该通过 `Database` 类进行

2. **清理孤立数据**
   - 如果发现仍有孤立数据，可以运行清理脚本
   - 建议定期检查数据完整性

3. **数据备份**
   - 删除操作不可逆，建议定期备份数据库
